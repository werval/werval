
== Introduction

QiWeb is a HTTP development kit.
QiWeb is not a full stack framework.

In other words, QiWeb don't compell you to use any persistence mechanism nor templating engine.
You are free to choose whatever may suit your needs.

image::images/overview.png[Overview,640]


== Application

A QiWeb Application is nothing but a plain old Java program.
The framework provide a default `main` class/method for you to reuse but you can also write yours if you need it.
The minimal requirement is a configuration file named `application.conf` containing a `app.secret` entry.


=== Structure

// TODO Application Structure Diagram - Code PoV


=== Modes

A QiWeb Application can run in three different modes:

. **Development**: the HTTP stack is single-threaded, source code is watched for changes, Application is restarted
on-demand and stacktraces are disclosed in responses.
. **Test**: the HTTP stack is single-threaded and Application run from compiled bytecode.
. **Production**: the HTTP stack is multi-threaded and Application run from compiled bytecode.


=== Runtime Models

A QiWeb Application can run according to three different runtime models:

. **Heavyweight**, with HTTP Service, most used runtime model for a HTTP application.
. **Middleweight**, with HTTP Context but without HTTP Service, typical runtime model for controller tests.
. **Lightweight**, with **no** HTTP support, usefull for applying the worker runtime model easily ; that is execute some
application code in a lightweight process.

TIP: See the Deploy on Heroku guide for lightweight mode usage example implementing Heroku workers.


=== Threading Model

QiWeb has a quite simple threading model based on the Netty one.

- Netty
    - Netty Selector Threads, default to `Runtime.availableProcessors()`
     -Netty IO Threads, default to `Runtime.availableProcessors()`
- Controllers
    - Optional Controller Execution Thread Pool
    - It means that by default, your controller code is executed on the IO Threads and that any controller doing
      blocking operations will slow your application down.


=== Summary

[cols="2a,4a,4a,4a"]
|===
||Development Mode |Test Mode |Production Mode

|**Heavyweight Runtime**
|Typical use while coding

- Single-thread HTTP stack `1*acceptors`+`1*acceptors`
- Reload on source changes
- Stacktraces disclosed in responses
|For tests that require a complete HTTP stack

- Single-thread HTTP stack `1*acceptors`+`1*acceptors`
- Compiled bytecode execution
|Typical production model

- Multi-thread HTTP stack `cores*acceptors`+`cores*io`
- Compiled bytecode execution

|**Middleweight Runtime**
|`404 No use case found`
|For QiWeb integrations tests that do not require a complete HTTP stack

- No true HTTP stack
- Compiled bytecode execution
|For **hackish** worker process that require an HTTP context but no HTTP stack

- No true HTTP stack
- Compiled bytecode execution

|**Lightweight Runtime**
|`404 No use case found`
|Typical use case for QiWeb integrations tests that need no HTTP support

- No HTTP support
- Compiled bytecode execution
|Typical worker process model

- No HTTP support
- Compiled bytecode execution

|===


== Logging

QiWeb use the http://www.slf4j.org[SLF4J] API (Simple Logging Facade for Java) but you have to choose what SLF4J
implementation to use.
We strongly recommend http://logback.qos.ch/[Logback].
You have full control on logging configuration.

All QiWeb loggers are present in the `org.qiweb` namespace according to code packages.
Here are the most useful:

- `org.qiweb.runtime.server` QiWeb Http Server
- `org.qiweb.runtime.routes` QiWeb Http Router
- `org.qiweb.runtime.controllers` QiWeb Controller
- `org.qiweb.runtime.filters` QiWeb Controller Filters
- etc...

TIP: QiWeb Runtime leverage SLF4J http://www.slf4j.org/manual.html#mdc[Mapped Diagnosic Context], aka. MDC, by putting
the current request ID at the `X-QiWeb-Request-ID` key.
Moreover, you can enable the `qiweb.http.log.context.client_ip` configuration property to add the current request client
IP address at the `X-QiWeb-Client-IP` key.
You can use theses keys in your loggers output patterns.


== Character encoding

By default all character encoding is done in UTF-8.
Character encoding can be changed by setting the `qiweb.character-encoding` configuration property.

QiWeb ignore the runtime platform default encoding and complies to its configuration only.
This is the only way to get a consistent behaviour accross different environments and prevent
https://en.wikipedia.org/wiki/Mojibake[mojibakes].

CAUTION: Even tough QiWeb does its best to ensure uniform character encoding for your application, you may use libraries
that don't.
In such a case you should http://stackoverflow.com/questions/361975/setting-the-default-java-character-encoding[set the
default Java character encoding] using the `file.encoding` system property.

All QiWeb APIs allows you to override character encoding when relevant.


== Configuration

NOTE: QiWeb configuration use the https://github.com/typesafehub/config/blob/master/HOCON.md[HOCON format] ("Human
Optimized Config Object Notation"). It is parsed using https://github.com/typesafehub/config[Typesafe Config].

The `application.conf` file must be present at the root of your classpath and must at least contain one single entry:
`app.secret` which is the secret key your application will use to sign session cookies.
For all other configuration properties, the QiWeb Runtime provide a `reference.conf` file that the Config library
automatically loads.
You can of course override all theses configuration properties in your `application.conf` file.

If you need to add configuration properties for your application you are encouraged to do so in your `application.conf`
file.

All configuration properties are available to your controllers and filters via the Context object.

[source,java]
----
import static org.qiweb.api.context.CurrentContext.*;
public MyController {
  public Outcome aControllerMethod() {
    String configValue = application().config().string("your.custom.config.key");
    // Do what you have to do according to the configuration value
    return outcomes().ok("whatever").build();
  }
}
----

All configuration properties can be overriden by defining System Properties.
This means that you can easily provide all configuration on the command line.

IMPORTANT: Every system property is also present in the configuration.
For example, the `java.home` System Property is automatically present in the configuration at the `java.home` key.
In other words, and if you need it, keep in mind that you can use configuration properties from the command line without
defining a default value in any configuration file.

Moreover, some special System Properties allow to use an alternate config file:

- `config.resource` to load configuration from the classpath
- `config.file` to load configuration from the filesystem
- `config.url` to load configuration from an URL

Note that this will replace the `application.conf` file, not add to it.
You still can leverage the inclusion mechanism of HOCON to include your `application.conf` file from the one you
specified using one of the System Properties described above.


== Lifecycle

=== Startup explained

=== Shutdown explained

Shutting your application down gracefully is as critical as running it.

When shut down is requested (Ctrl-C, kill command etc...) the runtime is put in shutting down state for a maximum
amount of time defined by the `qiweb.shutdown.timeout` configuration property that default to 5 seconds.
Obviously, if there are no requests to process your application will shutdown immediatly.

While shutting down, your application will continue to serve running requests till they complete.
Clients using HTTP 1.1 Keep-Alive will see your application respond with a `Connection` header with `Close` value and
effectively close the connection.

Moreover, your application will respond to new incoming requests with a `503 Service Unavailable` status.
You can set the `qiweb.shutdown.retry-after` configuration property so that a `Retry-After` header is added to theses
responses.

If your application is running on multiple nodes behind a balancer you can lower this value to 0, yes *zero*, allowing
your clients to reconnect immediatly to another node. Pretty useful for zero-downtime upgrades.


== The Global object

=== Instanciation

- Controllers
- Filters

=== Invocation

- Controllers
- Filters


== Error Handling

=== Error Records

When an error happen inside the Application it is recorded.

Theses record are held in-memory, if you want to persist them someway, you'll have to provide the appropriate mechanism.
See the section about the Global object above.

Each recorded Error has an `ID`, a timestamp, the related request `ID` and the original exception.
This is pretty useful as is to write unit/integration tests that check error handling in your Application.

By default, a maximum of `100` errors are held into memory in a *first-in/first-out* fashion.
You can increase or decrease this number by setting the `app.errors.record.max` configuration property.


== Routes

Routes are defined by:

- a HTTP method ;
- a path expression ;
- a fully qualified method name ;
- optionaly a method parameters definition ;
- and finaly optional modifiers.

The default QiWeb router allows for textual representation of routes definition.

    http-method path-expression controller-fqcn.method-name[(parameters)] [modifiers]

You can also express routes definitions in code using the Routes API.

Request URI Path and QueryString are the source of Controller Parameters.

You can also handle all the routing in your Global object.

NOTE: URI Fragment identifier is considered useful on the client side only, hence not taken into account when routing.
However, the reverse routing API allow you to append a fragment identifier to generated URIs.


== Controllers


== Outcomes


== Filters


== Session

As QiWeb is stateless oriented, it provides no way to keep session state server side.
Instead a simple session Cookie is used to keep state accross user requests.

TIP: If you need to keep server side state think about your database or cache system of choice.

The Session Cookie contains a `Map<String,String>` and is signed using the mandatory Application Secret.
Signature use the HmacSHA1 algorithm.


== Cookies


== Forms & Uploads


== WebSockets

== SSL

== Query String

// TODO put intro, ??? wikipedia ???? build plugin to fetch wikipedia and update ???

[source,java]
----
import static org.qiweb.api.context.CurrentContext.*;
public MyController {
  public Outcome aControllerMethod() {
    String singleFoo = request().queryString().singleValueOf("foo");
    // Do what you have to do according to the foo value
    return outcomes().ok("whatever").build();
  }
}
----


=== Multiple values

Query strings can contain multiple values for the same parameter.
How this is handled is not stated in the HTTP 1.0 nor 1.1 RFCs and, by so, open to interpretation.
You, and others, are free to do it the way you, or they, want.
This while being conform to the HTTP protocol.
See https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf[HTTP Parameter Pollution, 2009] at OWASP.

Frameworks usually handle this in their own each way.
When using one framework you get used to its way of doing things ovelooking the fact that you can get powned in pretty
silly ways.
See the OWASP paper cited above for numerous examples.

QiWeb, like other frameworks, has a default behaviour.
It's a bit simple, but this is for good.
No multi-value parameters is allowed.
A request coming with multiple values (eg. `foo=bar&foo=baz`) is, by default, rejected with a `400 Bad Request` status
and a warning is logged.

// TODO In dev-mode, put meta-data in exceptions with pointers to documentation!!!

On the other hand, and if you really need it, you can easily enable multiple values support by setting the
`qiweb.http.query-string.multi-valued` to yes.

TIP: Did you take a look at the OWASP link mentioned earlier? No? Now is a good time.

When enabled, `foo=bar&foo=baz` is accepted and your application code can access the values easily:

[source,java]
----
import static org.qiweb.api.context.CurrentContext.*;
public MyController {
  public Outcome aControllerMethod() {
    String singleFoo        = request().queryString().singleValueOf("foo"); <1>
    List<String> allFoos    = request().queryString().valuesOf("foo");      <2>
    String firstFoo         = request().queryString().firstValueOf("foo");  <3>
    String lastFoo          = request().queryString().lastValueOf("foo");   <4>
    // Do what you have to do according to the foo values
    return outcomes().ok("whatever").build();
  }
}
----
1. Get a single value, throws if there are multiple values
2. Get all values
3. Get first value
4. Get last value

The `QueryString` API leave you in control regarding which value you want to use.

NOTE: Enabling `qiweb.http.query-string.multi-valued` do not enable any *syntax*. A request with multiple `foo[]`
values will pass but the values will be in the `"foo[]"` parameter, not `"foo"`. Be careful, there's no magic.
Speaking of which, something along the line of Ruby on Rails
http://guides.rubyonrails.org/action_controller_overview.html#hash-and-array-parameters[Hash and Array Parameters]
could be implemented as a library, pull-requests are welcome!


== Testing

The `org.qiweb.test` module provide http://junit.org[JUnit] based construct to ease tests implementation.

First construct is `QiWebTest` that should be subclassed by your test classes.
Second one is `QiWebRule`, a JUnit Rule to be declared in your test classes.
Both have the same extension points, choose the one that suits your needs and habits.

Using the JUnit Rule is the prefered way of writing QiWeb tests as it don't force you to extend from any base class.

TIP: QiWeb JUnit Support has transparent integration with https://code.google.com/p/rest-assured/[rest-assured] if it is
detected on the tests classpath.
rest-assured base URL is automatically set accordingly to the QiWeb configuration so can use relative paths when using
it.

=== QiWebTest usage

[source,java]
----
import org.junit.Test;
import org.qiweb.test.QiWebTest;

public class MyTest extends QiWebTest {
  @Test
  public void myTest() {
    // Assert what you have to here
  }
}
----

Your Application will be activated/passivated around each test method.


=== QiWebRule usage

[source,java]
----
import org.junit.Rule;
import org.junit.Test;
import org.qiweb.test.QiWebTest;

public class MyTest {
  @Rule public QiWebRule qiweb = new QiWebRule();
  @Test
  public void myTest() {
    // Assert what you have to here
  }
}
----

As expected, this will activate/passivate your Application around each test method.

If you prefer to have your Application activated/passivated around each test class, use the JUnit `@ClassRule`
annotation.

[source,java]
----
import org.junit.ClassRule;
import org.junit.Test;
import org.qiweb.test.QiWebTest;

public class MyTest {
  @ClassRule public static final QiWebRule QIWEB = new QiWebRule();
  @Test
  public void myTest() {
    // Assert what you have to here
  }
}
----


=== In practice

- HTTP or not HTTP
- Automatic free port usage, allowing tests to be run in parallel
- Per Method / Per Class
- Logging
- Configuration
- Routes


=== Testing HTTP

The QiWeb Team recommend https://code.google.com/p/rest-assured/[rest-assured].
All HTTP assertions in the SDK are done using `rest-assured`, see the tests source code for numerous examples.


=== Testing browser based UIs

The QiWeb Team recommand http://fluentlenium.org/[FluentLenium].
All browser based UI assertions in the samples are done using `FluentLenium`, see the tests source code for numerous
examples.


== Plugins

QiWeb Plugins are bound to the Application lifecycle and provide an API to the Application code.
In other words, Plugins are activated/passivated alongside the Application and they provide a facade you can use in your
controllers/filters.

TIP: To use a plugin in your Application it is enough for it to be on the classpath and declared in your configuration.

Writing a plugin is as easy as implementing `org.qiweb.api.Plugin`.
As an example is worth a thousand words, we'll go through the process of writing a *Hello World* Plugin.

Our `HelloWorldPlugin` will expose a `HelloWorld` API to the Application code;

[source,java]
----
public class HelloWorld
{
    public String sayHello( String name )
    {
        return String.format( "Hello %s!", name );
    }
}
----

and by so be declared that way;

[source,java]
----
public class HelloWorldPlugin extends org.qiweb.api.PluginAdapter<HelloWorld>
{
    private final HelloWorld api = new HelloWorld();

    @Override
    public Class<HelloWorld> apiType()
    {
        return HelloWorld.class;
    }

    @Override
    public HelloWorld api()
    {
        return api;
    }    
}
----

Now, you need to register the Plugin into your Application in its configuration:

[source,bash]
----
app.plugins = [ "fqcn.of.HelloWorldPlugin" ]
----

Et voilà!
Finaly, here is how to use the Plugin from your Application code:

[source,java]
----
HelloWorld helloWorld = application().plugin( HelloWorld.class );
String greeting = helloWorld.sayHello( "World" );
// Do something clever with greeting
----

To go further, the `Plugin` interface declare two lifecycle methods:

- `onActivation( Application application );`
- `onPassivation( Application application );`

Theses two are NOOP methods in the `PluginAdapter` class used above.
Override theses to hook your Plugin in the Application lifecycle.

== Core Controllers and Filters

=== Controllers

- `Default`
- `Classpath`
- `Static`


=== Filters

- `@Cached`
- `@MDCSessionID`
- ...

